// import { AUDIO_DATA } from "./au/audioData.js";

export type AudioSample = {
  data: number[]
  cts: number
  timescale: number
}

export const HARD_HEADER = [
  // WebM EBML HEADER
  0x1a, 0x45, 0xdf, 0xa3, 0x9f, 0x42, 0x86, 0x81, 0x01, 0x42, 0xf7, 0x81, 0x01,
  0x42, 0xf2, 0x81, 0x04, 0x42, 0xf3, 0x81, 0x08, 0x42, 0x82, 0x84, 0x77, 0x65,
  0x62, 0x6d, 0x42, 0x87, 0x81, 0x04, 0x42, 0x85, 0x81, 0x02,

  // Segment start
  0x18, 0x53, 0x80, 0x67, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

  // Tracks
  0x15, 0x49, 0xa9, 0x66, 0xb2, 0x2a, 0xd7, 0xb1, 0x83, 0x0f, 0x42, 0x40, 0x4d,
  0x80, 0x8d, 0x4c, 0x61, 0x76, 0x66, 0x36, 0x30, 0x2e, 0x31, 0x36, 0x2e, 0x31,
  0x30, 0x30, 0x57, 0x41, 0x8d, 0x4c, 0x61, 0x76, 0x66, 0x36, 0x30, 0x2e, 0x31,
  0x36, 0x2e, 0x31, 0x30, 0x30, 0x44, 0x89, 0x88, 0x40, 0x8f, 0x40, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x16, 0x54, 0xae, 0x6b, 0xe0, 0xae, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x57, 0xd7, 0x81, 0x01, 0x73, 0xc5, 0x88, 0xd7, 0xc2, 0x8a,
  0xfb, 0x2d, 0x28, 0x57, 0x2c, 0x9c, 0x81, 0x00, 0x22, 0xb5, 0x9c, 0x83, 0x75,
  0x6e, 0x64, 0x86, 0x86, 0x41, 0x5f, 0x4f, 0x50, 0x55, 0x53, 0x56, 0xbb, 0x84,
  0x04, 0xc4, 0xb4, 0x00, 0x83, 0x81, 0x02, 0xe1, 0x91, 0x9f, 0x81, 0x02, 0xb5,
  0x88, 0x40, 0xe7, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x64, 0x81, 0x20,
  0x63, 0xa2, 0x97, 0x4f, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64, 0x01, 0x02,
  0x00, 0x00, 0x80, 0xbb, 0x00, 0x00, 0x00, 0x00, 0xff, 0x02, 0x00, 0x00, 0x01
]

function ebmlEncodeVint(x: number): number[] {
  if(x == 0) return [0b10000000]
  const bytesCnt = Math.ceil(Math.log2(x) / 7)

  const marker = 0b10000000 >> (bytesCnt - 1)
  const markerSetter = marker << ((bytesCnt - 1) * 8)
  x = x | markerSetter
  const res: number[] = []
  for(let i = 0; i < bytesCnt; i++) {
    res.push(x & 0xff)
    x >>= 8
  }
  return res.reverse()
}

function createBlock(frame: AudioSample) {
  const timeStamp = (frame.cts * 1000) / frame.timescale
  const header = [
    0xa3, // EMBL ID (Simple Block)
    ...ebmlEncodeVint(frame.data.length + 4), // LENGTH,
    0x81, // TRACK_ID (varint)
    (timeStamp >> 8) & 0xff,
    timeStamp & 0xff, // TIMESTAMP
    0x80 // FLAGS (keyframe)
  ]
  return header.concat(frame.data)
}

export function createOpusWebmCluster(data: AudioSample[]) {
  const clusterBodies = data.map(createBlock)
  const totalLen = clusterBodies.reduce((a, b) => a + b.length, 3) // 3 for timestampt

  const header = [
    0x1f,
    0x43,
    0xb6,
    0x75, // EBML ID (Cluster)
    ...ebmlEncodeVint(totalLen), // LENGTH
    0xe7,
    0x81,
    0x00 // TIME OF CLUSTER
  ]
  return header.concat(...clusterBodies)
}

// createCluster(AUDIO_DATA)
